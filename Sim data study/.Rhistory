#hamming_error_priv <- numeric(no_of_iter)
for (iter in 1:no_of_iter) {
data <- data_gen(n = n, theta = fixed_centered_theta, p = 1)
#hat_S_k <- top_k_borda_count(win_mat = data, k = k, lambda = 0)
#hat_S_k_priv <- top_k_borda_count(win_mat = data, k = k)
optim_theta <- optim(
par = fixed_centered_theta,
fn = obj_func,
gr = grad_obj_func,
win_mat = data,
n = nrow(data),
p = 1,
H = H_logistic,
grad_H = grad_H_logistic,
lambda = 0,
method = "BFGS"
)
L_infty_error[i, iter] <- max(abs(optim_theta$par  - fixed_centered_theta) /
max(abs(fixed_centered_theta)))
S_k = recover_top_k_set(fixed_centered_theta, k = k)
hat_S_k = recover_top_k_set(optim_theta$par, k = k)
hamming_error_est[i, iter] <- 1 - length(intersect(S_k, hat_S_k)) / k
optim_theta_priv <- optim(
par = fixed_centered_theta,
fn = obj_func,
gr = grad_obj_func,
win_mat = data,
n = nrow(data),
p = 1,
H = H_logistic,
grad_H = grad_H_logistic,
eps = 0.1,
method = "BFGS"
)
L_infty_error_priv[i, iter] <- max(abs(optim_theta_priv$par  - fixed_centered_theta) /
max(abs(fixed_centered_theta)))
hat_S_k_priv = recover_top_k_set(optim_theta_priv$par, k = k)
hamming_error_est_priv[i, iter] <- 1 - length(intersect(S_k, hat_S_k_priv)) / k
cat(iter)
}
print(i)
}
#function calculating the summary statistics like mean and sd
function_summary <- function(x){
mean = mean(x)
sd = sd(x)
return(c(mean = mean, sd = sd, lower_quantile = mean - 1.96 * sd, upper_quantile = mean + 1.96 * sd))
}
############ For Hamming Loss ###################
# mean and sd for non private sim study
sim_summary <- t(apply(hamming_error_est, 1, function_summary))
sim_summary <- data.frame(type = rep("NP",length(n_seq)), n_seq, sim_summary)
# mean and sd for private sim study
sim_summary_priv <- t(apply(hamming_error_est_priv, 1, function_summary))
sim_summary_priv <- data.frame(type = rep("P",length(n_seq)), n_seq, sim_summary_priv)
merged_sim_summary <- rbind(sim_summary, sim_summary_priv)
# mean and sd for non private sim study
sim_summary_L <- t(apply(L_infty_error, 1, function_summary))
sim_summary_L <- data.frame(type = rep("NP",length(n_seq)), n_seq, sim_summary_L)
# mean and sd for private sim study
sim_summary_priv_L <- t(apply(L_infty_error_priv, 1, function_summary))
sim_summary_priv_L <- data.frame(type = rep("P",length(n_seq)), n_seq, sim_summary_priv_L)
merged_sim_summary_L <- rbind(sim_summary_L, sim_summary_priv_L)
#install.packages("ggplot2")
#require(ggplot2)
ggplot(merged_sim_summary, aes(x = n_seq)) +
geom_line(aes(y = mean, colour = type)) +
geom_point(aes(y = mean, colour = type)) +
geom_errorbar(aes(y = mean,
ymin = lower_quantile,
ymax = upper_quantile,
colour = type)) +
xlab("n") +
ylab("average haming distance") +
theme_bw()
ggplot(merged_sim_summary_L, aes(x = n_seq)) +
geom_line(aes(y = mean, colour = type)) +
geom_point(aes(y = mean, colour = type)) +
geom_errorbar(aes(y = mean,
ymin = lower_quantile,
ymax = upper_quantile,
colour = type)) +
xlab("n") +
ylab("L infinity distance") +
theme_bw()
#Experiment - 1
k = round(n / 4)
n_seq <- seq(100, 200, 50)
no_of_iter <- 30
L_infty_error <- matrix(nrow = length(n_seq), ncol = no_of_iter)
L_infty_error_priv <- matrix(nrow = length(n_seq), ncol = no_of_iter)
hamming_error_est <- matrix(nrow = length(n_seq), ncol = no_of_iter)
hamming_error_est_priv <- matrix(nrow = length(n_seq), ncol = no_of_iter)
for (i in 1:length(n_seq)) {
n <- n_seq[i]
#k <- round(n / 2)
fixed_theta <- c(rnorm(n-k), rnorm(k, 1, 1))
fixed_centered_theta <- fixed_theta - mean(fixed_theta)
#S_k = recover_top_k_set(fixed_centered_theta)
#hamming_error <- numeric(no_of_iter)
#hamming_error_priv <- numeric(no_of_iter)
for (iter in 1:no_of_iter) {
data <- data_gen(n = n, theta = fixed_centered_theta, p = 1)
#hat_S_k <- top_k_borda_count(win_mat = data, k = k, lambda = 0)
#hat_S_k_priv <- top_k_borda_count(win_mat = data, k = k)
optim_theta <- optim(
par = fixed_centered_theta,
fn = obj_func,
gr = grad_obj_func,
win_mat = data,
n = nrow(data),
p = 1,
H = H_logistic,
grad_H = grad_H_logistic,
lambda = 0,
method = "BFGS"
)
L_infty_error[i, iter] <- max(abs(optim_theta$par  - fixed_centered_theta) /
max(abs(fixed_centered_theta)))
S_k = recover_top_k_set(fixed_centered_theta, k = k)
hat_S_k = recover_top_k_set(optim_theta$par, k = k)
hamming_error_est[i, iter] <- 1 - length(intersect(S_k, hat_S_k)) / k
optim_theta_priv <- optim(
par = fixed_centered_theta,
fn = obj_func,
gr = grad_obj_func,
win_mat = data,
n = nrow(data),
p = 1,
H = H_logistic,
grad_H = grad_H_logistic,
eps = 0.5,
method = "BFGS"
)
L_infty_error_priv[i, iter] <- max(abs(optim_theta_priv$par  - fixed_centered_theta) /
max(abs(fixed_centered_theta)))
hat_S_k_priv = recover_top_k_set(optim_theta_priv$par, k = k)
hamming_error_est_priv[i, iter] <- 1 - length(intersect(S_k, hat_S_k_priv)) / k
cat(iter)
}
print(i)
}
#function calculating the summary statistics like mean and sd
function_summary <- function(x){
mean = mean(x)
sd = sd(x)
return(c(mean = mean, sd = sd, lower_quantile = mean - 1.96 * sd, upper_quantile = mean + 1.96 * sd))
}
############ For Hamming Loss ###################
# mean and sd for non private sim study
sim_summary <- t(apply(hamming_error_est, 1, function_summary))
sim_summary <- data.frame(type = rep("NP",length(n_seq)), n_seq, sim_summary)
# mean and sd for private sim study
sim_summary_priv <- t(apply(hamming_error_est_priv, 1, function_summary))
sim_summary_priv <- data.frame(type = rep("P",length(n_seq)), n_seq, sim_summary_priv)
merged_sim_summary <- rbind(sim_summary, sim_summary_priv)
# mean and sd for non private sim study
sim_summary_L <- t(apply(L_infty_error, 1, function_summary))
sim_summary_L <- data.frame(type = rep("NP",length(n_seq)), n_seq, sim_summary_L)
# mean and sd for private sim study
sim_summary_priv_L <- t(apply(L_infty_error_priv, 1, function_summary))
sim_summary_priv_L <- data.frame(type = rep("P",length(n_seq)), n_seq, sim_summary_priv_L)
merged_sim_summary_L <- rbind(sim_summary_L, sim_summary_priv_L)
#install.packages("ggplot2")
#require(ggplot2)
ggplot(merged_sim_summary, aes(x = n_seq)) +
geom_line(aes(y = mean, colour = type)) +
geom_point(aes(y = mean, colour = type)) +
geom_errorbar(aes(y = mean,
ymin = lower_quantile,
ymax = upper_quantile,
colour = type)) +
xlab("n") +
ylab("average haming distance") +
theme_bw()
ggplot(merged_sim_summary_L, aes(x = n_seq)) +
geom_line(aes(y = mean, colour = type)) +
geom_point(aes(y = mean, colour = type)) +
geom_errorbar(aes(y = mean,
ymin = lower_quantile,
ymax = upper_quantile,
colour = type)) +
xlab("n") +
ylab("L infinity distance") +
theme_bw()
#require(ggplot2)
ggplot(merged_sim_summary, aes(x = n_seq)) +
geom_line(aes(y = mean, colour = type)) +
geom_point(aes(y = mean, colour = type)) +
geom_errorbar(aes(y = mean,
ymin = lower_quantile,
ymax = upper_quantile,
colour = type)) +
xlab("n") +
ylab("avergae haming distance") +
theme_bw()
#plot(1:length(n_seq),avg_hamming_error_priv, ty = 'l',  col = "red")
#plot(1:length(n_seq),avg_hamming_error_priv, ty = 'l',  col = "red")
#lines(1:length(n_seq),avg_hamming_error, ty = 'l')
#plot(1:length(n_seq),avg_hamming_error_priv, ty = 'l',  col = "red")
#lines(1:length(n_seq),avg_hamming_error, ty = 'l')
ggplot(merged_sim_summary_L, aes(x = n_seq)) +
geom_line(aes(y = mean, colour = type)) +
geom_point(aes(y = mean, colour = type)) +
geom_errorbar(aes(y = mean,
ymin = lower_quantile,
ymax = upper_quantile,
colour = type)) +
xlab("n") +
ylab("L infinity distance") +
theme_bw()
#Experiment - 1
k = round(30)
n_seq <- seq(100, 200, 50)
no_of_iter <- 3
L_infty_error <- matrix(nrow = length(n_seq), ncol = no_of_iter)
L_infty_error_priv <- matrix(nrow = length(n_seq), ncol = no_of_iter)
hamming_error_est <- matrix(nrow = length(n_seq), ncol = no_of_iter)
hamming_error_est_priv <- matrix(nrow = length(n_seq), ncol = no_of_iter)
for (i in 1:length(n_seq)) {
n <- n_seq[i]
#k <- round(n / 2)
fixed_theta <- c(rnorm(n-k), rnorm(k, 1, 1))
fixed_centered_theta <- fixed_theta - mean(fixed_theta)
#S_k = recover_top_k_set(fixed_centered_theta)
#hamming_error <- numeric(no_of_iter)
#hamming_error_priv <- numeric(no_of_iter)
for (iter in 1:no_of_iter) {
data <- data_gen(n = n, theta = fixed_centered_theta, p = 1)
#hat_S_k <- top_k_borda_count(win_mat = data, k = k, lambda = 0)
#hat_S_k_priv <- top_k_borda_count(win_mat = data, k = k)
optim_theta <- optim(
par = fixed_centered_theta,
fn = obj_func,
gr = grad_obj_func,
win_mat = data,
n = nrow(data),
p = 1,
H = H_logistic,
grad_H = grad_H_logistic,
lambda = 0,
method = "BFGS"
)
L_infty_error[i, iter] <- max(abs(optim_theta$par  - fixed_centered_theta) /
max(abs(fixed_centered_theta)))
S_k = recover_top_k_set(fixed_centered_theta, k = k)
hat_S_k = recover_top_k_set(optim_theta$par, k = k)
hamming_error_est[i, iter] <- 1 - length(intersect(S_k, hat_S_k)) / k
optim_theta_priv <- optim(
par = fixed_centered_theta,
fn = obj_func,
gr = grad_obj_func,
win_mat = data,
n = nrow(data),
p = 1,
H = H_logistic,
grad_H = grad_H_logistic,
eps = 0.5,
method = "BFGS"
)
L_infty_error_priv[i, iter] <- max(abs(optim_theta_priv$par  - fixed_centered_theta) /
max(abs(fixed_centered_theta)))
hat_S_k_priv = recover_top_k_set(optim_theta_priv$par, k = k)
hamming_error_est_priv[i, iter] <- 1 - length(intersect(S_k, hat_S_k_priv)) / k
cat(iter)
}
print(i)
}
#function calculating the summary statistics like mean and sd
function_summary <- function(x){
mean = mean(x)
sd = sd(x)
return(c(mean = mean, sd = sd, lower_quantile = mean - 1.96 * sd, upper_quantile = mean + 1.96 * sd))
}
############ For Hamming Loss ###################
# mean and sd for non private sim study
sim_summary <- t(apply(hamming_error_est, 1, function_summary))
sim_summary <- data.frame(type = rep("NP",length(n_seq)), n_seq, sim_summary)
# mean and sd for private sim study
sim_summary_priv <- t(apply(hamming_error_est_priv, 1, function_summary))
sim_summary_priv <- data.frame(type = rep("P",length(n_seq)), n_seq, sim_summary_priv)
merged_sim_summary <- rbind(sim_summary, sim_summary_priv)
# mean and sd for non private sim study
sim_summary_L <- t(apply(L_infty_error, 1, function_summary))
sim_summary_L <- data.frame(type = rep("NP",length(n_seq)), n_seq, sim_summary_L)
# mean and sd for private sim study
sim_summary_priv_L <- t(apply(L_infty_error_priv, 1, function_summary))
sim_summary_priv_L <- data.frame(type = rep("P",length(n_seq)), n_seq, sim_summary_priv_L)
merged_sim_summary_L <- rbind(sim_summary_L, sim_summary_priv_L)
#install.packages("ggplot2")
#require(ggplot2)
ggplot(merged_sim_summary, aes(x = n_seq)) +
geom_line(aes(y = mean, colour = type)) +
geom_point(aes(y = mean, colour = type)) +
geom_errorbar(aes(y = mean,
ymin = lower_quantile,
ymax = upper_quantile,
colour = type)) +
xlab("n") +
ylab("average haming distance") +
theme_bw()
ggplot(merged_sim_summary_L, aes(x = n_seq)) +
geom_line(aes(y = mean, colour = type)) +
geom_point(aes(y = mean, colour = type)) +
geom_errorbar(aes(y = mean,
ymin = lower_quantile,
ymax = upper_quantile,
colour = type)) +
xlab("n") +
ylab("L infinity distance") +
theme_bw()
#Experiment - 1
k = round(30)
n_seq <- seq(100, 200, 50)
no_of_iter <- 50
L_infty_error <- matrix(nrow = length(n_seq), ncol = no_of_iter)
L_infty_error_priv <- matrix(nrow = length(n_seq), ncol = no_of_iter)
hamming_error_est <- matrix(nrow = length(n_seq), ncol = no_of_iter)
hamming_error_est_priv <- matrix(nrow = length(n_seq), ncol = no_of_iter)
for (i in 1:length(n_seq)) {
n <- n_seq[i]
#k <- round(n / 2)
fixed_theta <- c(rnorm(n-k), rnorm(k, 1, 1))
fixed_centered_theta <- fixed_theta - mean(fixed_theta)
#S_k = recover_top_k_set(fixed_centered_theta)
#hamming_error <- numeric(no_of_iter)
#hamming_error_priv <- numeric(no_of_iter)
for (iter in 1:no_of_iter) {
data <- data_gen(n = n, theta = fixed_centered_theta, p = 1)
#hat_S_k <- top_k_borda_count(win_mat = data, k = k, lambda = 0)
#hat_S_k_priv <- top_k_borda_count(win_mat = data, k = k)
optim_theta <- optim(
par = fixed_centered_theta,
fn = obj_func,
gr = grad_obj_func,
win_mat = data,
n = nrow(data),
p = 1,
H = H_logistic,
grad_H = grad_H_logistic,
lambda = 0,
method = "BFGS"
)
L_infty_error[i, iter] <- max(abs(optim_theta$par  - fixed_centered_theta) /
max(abs(fixed_centered_theta)))
S_k = recover_top_k_set(fixed_centered_theta, k = k)
hat_S_k = recover_top_k_set(optim_theta$par, k = k)
hamming_error_est[i, iter] <- 1 - length(intersect(S_k, hat_S_k)) / k
optim_theta_priv <- optim(
par = fixed_centered_theta,
fn = obj_func,
gr = grad_obj_func,
win_mat = data,
n = nrow(data),
p = 1,
H = H_logistic,
grad_H = grad_H_logistic,
eps = 0.5,
method = "BFGS"
)
L_infty_error_priv[i, iter] <- max(abs(optim_theta_priv$par  - fixed_centered_theta) /
max(abs(fixed_centered_theta)))
hat_S_k_priv = recover_top_k_set(optim_theta_priv$par, k = k)
hamming_error_est_priv[i, iter] <- 1 - length(intersect(S_k, hat_S_k_priv)) / k
cat(iter)
}
print(i)
}
#function calculating the summary statistics like mean and sd
function_summary <- function(x){
mean = mean(x)
sd = sd(x)
return(c(mean = mean, sd = sd, lower_quantile = mean - 1.96 * sd, upper_quantile = mean + 1.96 * sd))
}
############ For Hamming Loss ###################
# mean and sd for non private sim study
sim_summary <- t(apply(hamming_error_est, 1, function_summary))
sim_summary <- data.frame(type = rep("NP",length(n_seq)), n_seq, sim_summary)
# mean and sd for private sim study
sim_summary_priv <- t(apply(hamming_error_est_priv, 1, function_summary))
sim_summary_priv <- data.frame(type = rep("P",length(n_seq)), n_seq, sim_summary_priv)
merged_sim_summary <- rbind(sim_summary, sim_summary_priv)
# mean and sd for non private sim study
sim_summary_L <- t(apply(L_infty_error, 1, function_summary))
sim_summary_L <- data.frame(type = rep("NP",length(n_seq)), n_seq, sim_summary_L)
# mean and sd for private sim study
sim_summary_priv_L <- t(apply(L_infty_error_priv, 1, function_summary))
sim_summary_priv_L <- data.frame(type = rep("P",length(n_seq)), n_seq, sim_summary_priv_L)
merged_sim_summary_L <- rbind(sim_summary_L, sim_summary_priv_L)
#install.packages("ggplot2")
#require(ggplot2)
ggplot(merged_sim_summary, aes(x = n_seq)) +
geom_line(aes(y = mean, colour = type)) +
geom_point(aes(y = mean, colour = type)) +
geom_errorbar(aes(y = mean,
ymin = lower_quantile,
ymax = upper_quantile,
colour = type)) +
xlab("n") +
ylab("average haming distance") +
theme_bw()
ggplot(merged_sim_summary_L, aes(x = n_seq)) +
geom_line(aes(y = mean, colour = type)) +
geom_point(aes(y = mean, colour = type)) +
geom_errorbar(aes(y = mean,
ymin = lower_quantile,
ymax = upper_quantile,
colour = type)) +
xlab("n") +
ylab("L infinity distance") +
theme_bw()
################################################################################
Non - Parametric
plot_sim_results <- function(sim_results, sim_results_priv, label_of_y){
# mean and sd for non private sim study
sim_summary <- t(apply(sim_results, 1, function_summary))
sim_summary <- data.frame(type = rep("NP",length(n_seq)), n_seq, sim_summary)
# mean and sd for private sim study
sim_summary_priv <- t(apply(sim_results_priv, 1, function_summary))
sim_summary_priv <- data.frame(type = rep("P",length(n_seq)), n_seq, sim_summary_priv)
merged_sim_summary <- rbind(sim_summary, sim_summary_priv)
ggplot(merged_sim_summary, aes(x = n_seq)) +
geom_line(aes(y = mean, colour = type)) +
geom_point(aes(y = mean, colour = type)) +
geom_errorbar(aes(y = mean,
ymin = lower_quantile,
ymax = upper_quantile,
colour = type)) +
xlab("n") +
ylab(paste0(label_of_y)) +
theme_bw()
}
plot_sim_results <- function(sim_results, sim_results_priv, label_of_y = "Loss"){
# mean and sd for non private sim study
sim_summary <- t(apply(sim_results, 1, function_summary))
sim_summary <- data.frame(type = rep("NP",length(n_seq)), n_seq, sim_summary)
# mean and sd for private sim study
sim_summary_priv <- t(apply(sim_results_priv, 1, function_summary))
sim_summary_priv <- data.frame(type = rep("P",length(n_seq)), n_seq, sim_summary_priv)
merged_sim_summary <- rbind(sim_summary, sim_summary_priv)
ggplot(merged_sim_summary, aes(x = n_seq)) +
geom_line(aes(y = mean, colour = type)) +
geom_point(aes(y = mean, colour = type)) +
geom_errorbar(aes(y = mean,
ymin = lower_quantile,
ymax = upper_quantile,
colour = type)) +
xlab("n") +
ylab(paste0(label_of_y)) +
theme_bw()
}
plot_sim_results(hamming_error_est,hamming_error_est_priv, "hamming loss")
plot_sim_results(L_infty_error,L_infty_error_priv, "l infty loss")
#Experiment - 1
k = round(n/4)
n_seq <- seq(100, 200, 50)
no_of_iter <- 35
L_infty_error <- matrix(nrow = length(n_seq), ncol = no_of_iter)
L_infty_error_priv <- matrix(nrow = length(n_seq), ncol = no_of_iter)
hamming_error_est <- matrix(nrow = length(n_seq), ncol = no_of_iter)
hamming_error_est_priv <- matrix(nrow = length(n_seq), ncol = no_of_iter)
for (i in 1:length(n_seq)) {
n <- n_seq[i]
#k <- round(n / 2)
fixed_theta <- c(rnorm(n-k), rnorm(k, 1, 1))
fixed_centered_theta <- fixed_theta - mean(fixed_theta)
#S_k = recover_top_k_set(fixed_centered_theta)
#hamming_error <- numeric(no_of_iter)
#hamming_error_priv <- numeric(no_of_iter)
for (iter in 1:no_of_iter) {
data <- data_gen(n = n, theta = fixed_centered_theta, p = 1)
#hat_S_k <- top_k_borda_count(win_mat = data, k = k, lambda = 0)
#hat_S_k_priv <- top_k_borda_count(win_mat = data, k = k)
optim_theta <- optim(
par = fixed_centered_theta,
fn = obj_func,
gr = grad_obj_func,
win_mat = data,
n = nrow(data),
p = 1,
H = H_logistic,
grad_H = grad_H_logistic,
lambda = 0,
method = "BFGS"
)
L_infty_error[i, iter] <- max(abs(optim_theta$par  - fixed_centered_theta) /
max(abs(fixed_centered_theta)))
S_k = recover_top_k_set(fixed_centered_theta, k = k)
hat_S_k = recover_top_k_set(optim_theta$par, k = k)
hamming_error_est[i, iter] <- 1 - length(intersect(S_k, hat_S_k)) / k
optim_theta_priv <- optim(
par = fixed_centered_theta,
fn = obj_func,
gr = grad_obj_func,
win_mat = data,
n = nrow(data),
p = 1,
H = H_logistic,
grad_H = grad_H_logistic,
eps = 0.5,
method = "BFGS"
)
L_infty_error_priv[i, iter] <- max(abs(optim_theta_priv$par  - fixed_centered_theta) /
max(abs(fixed_centered_theta)))
hat_S_k_priv = recover_top_k_set(optim_theta_priv$par, k = k)
hamming_error_est_priv[i, iter] <- 1 - length(intersect(S_k, hat_S_k_priv)) / k
cat(iter)
}
print(i)
}
plot_sim_results(hamming_error_est,hamming_error_est_priv, "hamming loss")
plot_sim_results(L_infty_error,L_infty_error_priv, "l infty loss")
